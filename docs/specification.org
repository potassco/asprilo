#+TITLE: ASPRILO Problem Specification
#+AUTHOR: Philipp Obermeier
#+INCLUDE: "./conf.org"

* About

  This is the problem specification of [[file:index.org][ASPRILO]]. Subsequently, we
  - gradually specify the problem domain in different variations, beginning with the default scope
  - stipulate the technical instance and plan format
  - provide a example instance and plan


* Default Problem Domain (DEF)
  :PROPERTIES:
  :CUSTOM_ID: cid-b0f981f8-3202-42c0-a46e-aa6f1a52629b
  :END:

  ASPRILO's benchmark scenario is inspired by intra-logistics and warehouse automation systems based
  on multiple mobile robots and shelves. Its main goal is order fulfilment in a warehouse, i.e.,
  order picking and sortation for a given set of product orders. Specifically, the warehouse floor
  is laid out as a 2-dimensional grid. Products are stored in shelves, each located in a single grid
  node. Mobile robots can move and navigate through the warehouse along the grid. Moreover, they can
  carry and relocate shelves, as well as bring them to picking stations to deliver
  products. Initially, all orders are known. An order is fulfilled if all its requested product
  units are delivered to a picking station. The overall goal is hence to provide a plan in form of a
  sequence of sets of robot actions such that all orders will be filled. In other words, the plan
  should be based off a discrete time signal and each robot may perform a single action per time
  point, i.e., robots may act concurrently. In the following, we provide a more detailed overview of
  the /key components/ of the problem.

** Warehouse Floor Layout
   :PROPERTIES:
   :CUSTOM_ID: cid-7e4e0e03-fa41-4809-8f83-b8e6a19986d7
   :END:

   The warehouse floor is typically laid out as a /grid/, i.e.,
   - a 2-dimensional /grid graph/; or
   - a /partial/ 2D grid graph (i.e., subgraph of a grid) to resemble more complex shapes:
     e.g. several rectangles connected by smaller passages, a cross-shaped grid, etc.

   The grid may also contain special /highway nodes/ that must never be occupied by a parked shelf.
   Besides, we refer to grid nodes also as /storage nodes/ if they are neither occupied by a
   picking station nor are a highway node.

** Products

   A /product/ is a type of physical good that owns an unique identifier (e.g. part number,
   universal product code). Products are typically handled in certain quantities, i.e., number of /units/,
   e.g. 20 units of the product with unique identifier '7324552'.

   # /Products/ are stored in /shelves/, i.e., portable storage units, each located at and consuming
   #   the space of a single grid node

** Shelves

   /Shelves/ store product units in limited quantities. Further, they occupy exactly one grid node
   when parked.

** Robots

   Mobile /robots/ can freely move along the grid (even under shelves) as long as the grid node is
   not already occupied by another robot.  Further, they can /pick up/ a shelf when under it,
   /carry/ it while moving, and /put it down/ eventually. While carrying a shelf, their movement is
   restricted to fields clear of other shelves and robots. At a picking station, robots can /deliver/
   product units from their shelf to the totes of the station. Moreover, robots occupy exactly one
   grid node at each time point.

** Picking Stations

   Picking stations store product units requested by orders for further processing. Further, picking stations consume one
   grid node, and a robot can occupy the same node as picking station in order to deliver product
   units to it.

** Orders

   /Orders/ are sets of /order lines/, i.e., a set of requests for products in certain quantities,
   e.g. an order with 3 lines:
     + 3 pens
     + 2 notebooks
     + 1 file folder

   All orders are known initially (instead of arriving over time). Further, an order contains each
   at most one order line per product. An order is /fulfilled/ if all its requested product units
   are delivered to a picking station.


* Key Characteristics of Instances (Default Problem Domain)
  :PROPERTIES:
  :ID:       ea45aa7c-4378-4d9e-86ec-5846486b2d2f
  :END:

  Here, we present the characteristics (without any claim of completeness) that we consider relevant
  to distinguish problem instances. This is a preliminary step for our subsequent problem
  classification which is, in turn, implemented by our [[file:manual.org::#cid-c66ba478-f621-4b18-acb1-3ea2e4bf7110][instance generator]]. Instance characteristics
  can be further divided up into aspects related to the instance's warehouse and set of orders,
  respectively. Moreover, instance characteristics depend on the scope of the problem domain, and
  the order set properties also depend on the warehouse characteristics.  In the following, we list
  our instance characteristics for the default problem, and later expand on those in connection with
  [[#cid-bbacc203-29c4-489f-8661-95cf4b599fdd][problem domain modifications]].

** Warehouse Characteristics
   :PROPERTIES:
   :CUSTOM_ID: cid-1ff2ac2f-a6f1-4ddd-b0f0-5e3d2af2d4d0
   :END:

   Besides the problem scope, the key aspects of the warehouse boil down to its floor plan
   layout for which we can identify the following criteria.

*** Floor Topology Type
    :PROPERTIES:
    :CUSTOM_ID: cid-b3c44568-d34b-4c4d-bac0-a1483b4a99e8
    :END:

    For the floor topology, we distinguish between two basic graph types:
     - grid graph (default)
     - general two-dimensional graph[fn:notimplemented]


*** Floor Topology Layout

    In case the [[#cid-b3c44568-d34b-4c4d-bac0-a1483b4a99e8][floor topology type]] is a grid, the topology layout is a rectangular grid graph by
    default. Further, we can consider more complex grid shapes, e.g. several rectangles connected by
    smaller corridors, a cross-shaped grid, a T-shaped grid, etc.

    If the topology type is a general graph, we do not regard its layout at present.


*** Interiors Layout: Placement of Highway Nodes, Shelves and Picking Stations
    :PROPERTIES:
    :CUSTOM_ID: cid-d70674e1-8273-4abb-8ebf-b05f261c621a
    :END:

    Here, we distinguish whether highway nodes, shelves and picking stations are placed randomly on
    the grid or if a distinct pattern for the interiors layout is employed. For instance, a most
    typical pattern (see Fig. [[fig:example-inst]]) for rectangular warehouse grids is as follows:
    - shelves are placed in the center of the grid, divided up equally into rectangular clusters
    - picking stations evenly distributed around the edge of the grid;
    - one belt-way highway at the edge of the grid encompassing the shelves in the center;
    - many smaller lanes through the fields with shelves in the center of the grid.

    In the following, we refer to this pattern as /default interiors layout/.


*** Reachability of Shelves

    A shelf is /reachable/ if it can be carried to each picking station without moving other shelves
    to clear path. A warehouse fulfills the /shelf-reachability/ criterion if all shelves are
    reachable.


*** Floor Size

    We consider the floor size in terms of number of grid nodes. Naturally, in the case that the
    floor is a regular grid (instead of a partial one), it suffices to specify the x- and
    y-dimensions of the grid to entail the number of grid nodes.


*** Quantities of Interior Objects

    We consider the quantities of interior objects, i.e., the number of
    - highway nodes
    - shelves
    - picking stations
    - robots


*** Dimensions of Shelf Clusters

    In conjunction with the [[#cid-d70674e1-8273-4abb-8ebf-b05f261c621a][interiors layout]], we consider the dimension of rectangular shelf cluster
    in x- and y-directions.


*** Ratio Between The Number of Shelves and Storage Nodes[fn:notimplemented]

    We consider the floored ratio between the number of shelves an the storage nodes in the
    warehouse.



** Order Set Characteristics
   :PROPERTIES:
   :CUSTOM_ID: cid-119945ff-c477-4214-98fd-a3078f9bf457
   :END:

   For order sets, we identified the following key aspects.

*** Number of Orders

    We consider the total of number of orders posed by the instance.

*** Minimum, Maximum and Average Number of Order Lines per Order

    We consider the minimum, maximum and floored average number of lines per order.

*** Ratio Between the Number of Ordered and Overall Products[fn:notimplemented]

    We consider the floored ratio between the number of ordered and overall available products in
    the warehouse. This is not be confused with the number of ordered and available product units.


* Problem Domain Modifications
  :PROPERTIES:
  :CUSTOM_ID: cid-bbacc203-29c4-489f-8661-95cf4b599fdd
  :END:

  Based on the [[#cid-b0f981f8-3202-42c0-a46e-aa6f1a52629b][default problem domain]], we can envision various additional modifications. For each,
  we will subsequently describe it and enumerate the additional and changed instance characteristics
  in comparison to the default problem. Besides, we will also point out if a modification changes
  the overall goal of the problem.

  In the heading of a paragraph that describes a modification, its acronym is given in parentheses.
  Further, if the modification represents a simplification of the default domain, it is additionally
  labelled as such within the parentheses too.


** Disregard of Product Quantities (DPQ/Simplification)
   :PROPERTIES:
   :CUSTOM_ID: cid-49448523-5e9b-4ed2-ac1a-6754d838b85c
   :END:

   This is a simplification of the default domain in sense that we completely ignore product
   quantities.  That is, we pretend that products on shelves are available in infinite quantities
   and hence order lines only specify the product but not its quantity, since the latter is
   consequently redundant. With that, a shelf at a picking station can fill an order if it holds the
   required product.


*** Changed Order Characteristics

**** Ratio Between the Number of Ordered and Overall Products

     Not applicable here.


** Instant Concurrent Deliveries (ICD/Simplification)
   :PROPERTIES:
   :CUSTOM_ID: cid-f8d8f6b9-771a-4b1d-a20d-1ce03f96086b
   :END:

   This is a simplification of the default domain in the sense that for a robot at a picking
   station, all deliveries can be processed in parallel and within a single time step.

** Movements Only (MOO/Simplification)
   :PROPERTIES:
   :CUSTOM_ID: cid-8dcd778b-8504-449d-9811-39ec61c50cbb
   :END:

   This is a simplification of the default domain in the sense the only action that robots can
   perform is move, i.e., there are no pickup, putdown or delivery actions in plans.  With that, we
   need to define when a robot /implicitly/ picks up or puts down a shelf as well as delivers items at
   a picking station: specifically, a robot
   - picks up a shelf as soon as he is beneath one and not carrying it already;
   - when at a picking station and carrying a shelf, all possible (with respect to unfilled order
     lines and available quantities on the shelf) deliveries are concurrently executed in a single
     time step
   - when carrying a shelf, can only put it down at the same node where it was originally picked-up.


** Product Capacity for Robots and Shelves Based on Quantity (CAQ)
   :PROPERTIES:
   :CUSTOM_ID: cid-9828decd-6d59-4ccc-94c2-847b3a6b7a08
   :END:

   Robots and Shelves have a maximum quantity of products they can carry.

*** Additional Warehouse Characteristics

**** Mean Capacity of Shelves

     Mean (average, median, geometric, etc.) capacity of shelves.


**** Mean Capacity of Robots

     Mean (average, median, geometric, etc.) capacity of robots.


** Product Capacity for Robots and Shelves Based on Weight (CAW)
   :PROPERTIES:
   :CUSTOM_ID: cid-87f0ecc2-45ff-4d7c-8583-8b5ed4c5fbbe
   :END:

   Products have specifics weights, and robots and shelves have a maximum weight capacity they can carry.

*** Additional Warehouse Characteristics

**** Mean Capacity of Shelves

     Mean (average, median, geometric, etc.) capacity of shelves.


**** Mean Capacity of Robots

     Mean (average, median, geometric, etc.) capacity of robots.




** Product Capacity for Robots and Shelves Based on Volume (CAV)
   :PROPERTIES:
   :CUSTOM_ID: cid-8c423d59-0c08-422f-b94d-720a0b6908e2
   :END:

   Products have specific volumes (i.e., the amount of enclosed space), and robots and shelves have a
   maximum volume of products they can carry.

*** Additional Warehouse Characteristics

**** Mean Capacity of Shelves

     Mean (average, median, geometric, etc.) capacity of shelves.


**** Mean Capacity of Robots

     Mean (average, median, geometric, etc.) capacity of robots.




** Energy Management (EMA)
   :PROPERTIES:
   :CUSTOM_ID: cid-d8cd3118-7e68-4f20-8c1e-d868d32a96a3
   :END:

   Robots have electrical batteries and a consume energy for each action. Before a robot runs out of
   energy, it has to move to a /charging stations/ to recharge its battery. Those stations occupy a
   floor node and a single robot can enter them at a time. Further, each charging station has a
   distinct charge rate.

*** Additional Warehouse Characteristics

**** Placement/Number/Ratio of Charging Stations

     We consider
     - placement layout of charging stations (e.g. all stations evenly distributed across the floor
       vs. all located within a small area of the floor)
     - number of charging stations
     - ratio of charging stations w.r.t robots and floor size.


**** Mean Robots' Battery Capacity

     Mean (average, median, geometric, etc.) robots' battery capacity.


**** Mean Robots' Recharge Speed

     Mean (average, median, geometric, etc.) amount of energy a robot can recharge at a charging station at each time step.


**** Mean Battery Capacity

     Mean (average, median, geometric, etc.) battery capacity of a robot.


**** Mean Robots' Energy Consumption

     Mean (average, median, geometric, etc.) amount of energy consumed by robot actions independent
     of the type of action.


*** Changed Warehouse Characteristics

**** Interiors Layout: Placement of Charging Stations

     In addition to the default problem's interiors layout, the placement of the charging stations
     stations have to be considered too.

     TODO: default pattern


** Replenishment (REP)
   :PROPERTIES:
   :CUSTOM_ID: cid-d84e72a4-2202-4331-8636-b56dd264c641
   :END:

   The warehouse, i.e., its shelf are periodically replenished by suppliers. To that end the
   warehouse needs to order products from suppliers who deliver those with a certain delay to the
   replenishment stations in the warehouse. To retrieve product units from a replenishment station,
   a robot can bring a shelf to it for restocking. Further, each shelf has only a limited capacity
   to store products.

*** Changed Warehouse Characteristics

**** Interiors Layout: Placement of Replenishment Stations

     In addition to the default problem's interiors layout, the placement of the replenishment
     stations have to be considered too.

     TODO: default pattern


** Orders Expire After Timeout (OEX)
   :PROPERTIES:
   :CUSTOM_ID: cid-88ef4c01-95a6-45f6-9d2c-b3b3c493964e
   :END:

   Each order expires after a specific timeout, i.e., number of time steps. The countdown starts
   upon the arrival of the order. An order cannot be fulfilled after it has expired.

*** Additional Order Set Characteristics

**** Mean Expiration Timeout for Orders

     Mean (average, median, geometric, etc.) expiration timeout for orders.


** Orders Assigned To Picking Stations (OPS)
   :PROPERTIES:
   :CUSTOM_ID: cid-58b1d9d1-786b-4f92-b233-ddeb1e29dbb9
   :END:

   Each order is assigned to a specific picking stations to which its order lines have to be
   delivered.


** Online Processing of Orders, Orders Expire After Timeout (OOP)
   :PROPERTIES:
   :CUSTOM_ID: cid-1610eaee-45fb-476f-8184-403d386311b9
   :END:

   The set of orders is streamed in over time where each time step corresponds to an amount of
   seconds. Further, we assume that [[#cid-88ef4c01-95a6-45f6-9d2c-b3b3c493964e][orders expire as described before]] and hence the planning system
   has to process them online.

*** Additional Order Set Characteristics

**** Mean Number of Expiring Order Lines per Second

     Mean (average, median, geometric, etc.) number of expiring order lines per second.

*** Change of Overall Problem Goal

    At each time point, all unfulfilled orders must not expire.


* Supported Combinations of Modifications

  In the table below, we list all (planned to be) supported combinations of modifications.  Further,
  our supported combinations are chosen such that they represent a well-ordered set

  #+CAPTION: Supported combinations of problem modifications
  | "Distance" to DEF | Combinations          |
  |-------------------+-----------------------|
  |                 / | <>                    |
  |                 0 | DEF                   |
  |                -1 | DEF + DPQ             |
  |                -2 | DEF + DPQ + ICD       |
  |          - \infty | DEF + DPQ + ICD + MOO |


** Principally Possible Combinations

   In table below, we illustrate pair-wise combinations of problem modifications that we consider
   possible in principle but not necessarily (planned to be) supported by our tools.

   #+CAPTION: Principally possible pairwise combinations of problem modifications.
   |     | DPQ        | CAQ        | CAW        | CAV        | EMA        | REP        | OEX        | OPS        | OOP        |
   |-----+------------+------------+------------+------------+------------+------------+------------+------------+------------|
   | /   | <          |            |            |            |            |            |            |            | >          |
   | DPQ |            |            |            |            | \checkmark |            | \checkmark | \checkmark | \checkmark |
   | CAQ |            |            |            |            | \checkmark | \checkmark | \checkmark | \checkmark | \checkmark |
   | CAW |            |            |            | \checkmark | \checkmark | \checkmark | \checkmark | \checkmark | \checkmark |
   | CAV |            |            | \checkmark |            | \checkmark | \checkmark | \checkmark | \checkmark | \checkmark |
   | EMA | \checkmark | \checkmark | \checkmark | \checkmark |            | \checkmark | \checkmark | \checkmark | \checkmark |
   | REP |            | \checkmark | \checkmark | \checkmark | \checkmark |            | \checkmark | \checkmark | \checkmark |
   | OEX | \checkmark | \checkmark | \checkmark | \checkmark | \checkmark | \checkmark |            | \checkmark | \checkmark |
   | OPS | \checkmark | \checkmark | \checkmark | \checkmark | \checkmark | \checkmark | \checkmark |            | \checkmark |
   | OOP | \checkmark | \checkmark | \checkmark | \checkmark | \checkmark | \checkmark | \checkmark | \checkmark |            |

   A combination of more than two modifications is possible if there is a possible pairwise
   combination for all modifications in question.


* Classification of Instances

  Having a clear notion of the problem's domain and key characteristics, we are now ready to
  systematically categorize its instances. In particular, we hierarchically classify sub-problems
  and their instances based on their
  1. problem scope ([[#cid-b0f981f8-3202-42c0-a46e-aa6f1a52629b][default domain]] and [[#cid-bbacc203-29c4-489f-8661-95cf4b599fdd][potential modifications]])
  2. [[#cid-1ff2ac2f-a6f1-4ddd-b0f0-5e3d2af2d4d0][warehouse characteristics]] (in context of the problem scope)
  3. [[#cid-119945ff-c477-4214-98fd-a3078f9bf457][order set characteristics]] (in context of the problem scope and warehouse characteristics)
  in descending order, also illustrated in Fig. [[fig:classification]].

  #+BEGIN_SRC dot :file img/dot_classification.png :cmdline -Kdot -Tpng
    digraph {
            subgraph clusterA {label="1. Problem Scope\n(e.g. Default Domain + DPQ)"
                    subgraph clusterB {label="2. Warehouse Characteristics\n(e.g. 10x10 grid, 20 shelves, 2 picking stations, 5 robots, default interiors layout)"
                            node [shape=box] "3. Order Set Characteristics\n(e.g. 10 orders, 2 order lines in avg, 40% of available products ordered)";
                    }
            }
    }
  #+END_SRC

  #+CAPTION: Hierarchical classification of instances.
  #+NAME: fig:classification
  #+RESULTS:
  [[file:img/dot_classification.png]]



* Input Format

** General Concepts: Object-Types and Attributes
   :PROPERTIES:
   :CUSTOM_ID: cid-f23fad45-7955-4f07-87ff-5370456e374b
   :END:

   At first, we need to agree on a general encoding schema for instances. In particular, we
   introduce
   - [[#cid-c06c73df-12c0-4fd6-977a-8f1ad64309be][object types]] which are all predetermined by the domain; as well as
   - concrete [[#cid-045df828-ed63-4a81-aa62-eba5c612e9f1][object]] and [[#cid-035d4a73-f8d3-482b-b091-6dddef6d65ae][object-subtype]] definitions which are both specified by instances.

*** Object-Types
    :PROPERTIES:
    :CUSTOM_ID: cid-c06c73df-12c0-4fd6-977a-8f1ad64309be
    :END:

    For the technical specification of problem instances, we first need to identify the
    /objects-types/ relevant to the problem. Specifically, an object-type represents a subset of the
    objects in the problem domain. Additionally, it defines a set of /attributes/ common to its
    objects. Further, applicable object-types and attributes may vary depending on the problem
    scope. For example, we determine the following object-types for the default problem:

    - ~grid-node~ with attribute ~at~
    - ~robot~ with attribute ~at~
    - ~shelf~ with attribute ~at~
    - ~product~ with attribute ~on~
    - ~order~ with attributes ~line~ and ~pickingStation~
    - ~pickingStation~ with attribute ~at~

    The complete list of [[#cid-c279ce9c-c2ab-4e3f-9ec3-df2dd3a38188][expected object types and their attributes]] is given below.


*** Object Definitions
    :PROPERTIES:
    :CUSTOM_ID: cid-045df828-ed63-4a81-aa62-eba5c612e9f1
    :END:

    All instance data (except object-subtypes) is represented as ~init/2~ facts of the format
    #+BEGIN_SRC prolog
      init(object(<object-type>, <object-id>), value(<attribute>, <value>)).
    #+END_SRC
    where
    - function ~object~ refers to an object by its type ~<object-type>~ and relative identifier
      ~<object-id>~, e.g. ~object(robot, 34)~ for a robot with ID 34
    - function ~value~ specifies that the object's attribute ~<attribute>~ has value ~<value>~ e.g.
      #+BEGIN_SRC prolog
        init(object(robot, 34), value(at, (2,3))).
      #+END_SRC
      states that the robot 34 is at x/y-location (2,3).


*** Object-Subtype Definitions
    :PROPERTIES:
    :CUSTOM_ID: cid-035d4a73-f8d3-482b-b091-6dddef6d65ae
    :END:

    #+BEGIN_SRC prolog
      init(subtype(<object-type>, <subtype-id>), value(<attribute>, <value>))
    #+END_SRC

    Object-Subtypes refine object-types in terms of a common characteristics, e.g. shelves with same
    capacity, robots with same maximum payload weight, products of the category 'food', etc. To
    define an object-subtype of a given object-type, one uses facts of the form
    #+BEGIN_SRC prolog
      init(subtype(<object-type>, <subtype-id>), value(<attribute>, <value>)).
    #+END_SRC
    where
    - function ~subtype~ refers to a subtype by its parent object-type <object-type> and its
      relative identifier <subtype-id>, e.g. ~subtype(robot, 3)~ for a subtype of ~robot~ with RID 3
    - function ~value~ specifies that the subtype's attribute ~<attribute>~ has value ~<value>~,
      e.g.for a given object-type ~robot~
      #+BEGIN_SRC prolog
        init(subtype(robot, 3), value(maxEnergy, 250)).
      #+END_SRC
      states that robots of object-subtype 3 have a battery with maximum energy capacity of 250.

    To declare that an object-type belongs to a object-subtype the attribute ~subtype~ is
    used, e.g.
    #+BEGIN_SRC prolog
        init(object(robot, 34), value(subtype, 3)).
    #+END_SRC
    states that robot 34 is of object-subtype 3 and hence "inherits" the maximum energy capacity of
    250.

    In general, any ~value~ to ~attribute~ assignment of an object may be determined by an
    associated object-subtype, except for ~subtype~ itself. However, for each object and ~attribute~,
    there may only exists at most one ~value~ assignment, including the assignments inherited from
    the object's subtypes.


** Expected Object Types and Attributes
   :PROPERTIES:
   :CUSTOM_ID: cid-c279ce9c-c2ab-4e3f-9ec3-df2dd3a38188
   :END:

*** Warehouse Floor (Grid Topology)

    In case the [[#cid-b3c44568-d34b-4c4d-bac0-a1483b4a99e8][floor topology type]] is a grid, the [[file:specification.org::#cid-7e4e0e03-fa41-4809-8f83-b8e6a19986d7][warehouse floor]] uses exclusively *either*
    object-type ~grid~ or objec-type ~node~ for its specification.

**** Specified by Dimensions (~grid~)
     - For the simple case that the warehouse is a (regular) grid, i.e., all nodes of the grid can be
       occupied by robots and shelves, it suffices to state the grid's x,y-dimension via attribute
       ~xsize~ and ~ysize~, e.g.
       #+BEGIN_SRC prolog
         init(object(grid,1), value(xsize, 45)).
         init(object(grid,1), value(ysize, 35)).
       #+END_SRC
       states that the x,y-dimensions are 45 and 35.

**** Specified by Nodes (~node~)
     - For the more general case that warehouse is a partial grid, i.e., only specific nodes
       of a warehouse grid can be occupied by robots and shelves, each of those nodes has to be
       explicitly stated via attribute ~at~, e.g.
       #+BEGIN_SRC prolog
         init(object(node, 1), value(at, (1,5))).
         init(object(node, 2), value(at, (2,5))).
       #+END_SRC
       states that there exist grid nodes 1 and 2 at coordinates (1,5) and (2,5), resp.
     - Remark: in the problem encoding, ~node~ facts can be seen as generalization of ~grid~ in the
       sense that ~grid~ facts can always be translated to corresponding ~node~ facts.


*** Warehouse Floor (Grid Topology)

    TODO: floor encoding for general topology graphs


*** Robots

    [[*Robots][Robots]] use object-type ~robot~ for their specification. Their attributes are defined depending
    on the problem domain scope as follows:

**** Attributes Related to [[#cid-b0f981f8-3202-42c0-a46e-aa6f1a52629b][Default Domain]]

     - The grid position of a robot is indicated by attribute ~at~, e.g.
       #+BEGIN_SRC prolog
         init(object(robot, 1), value(at, (2,3))).
       #+END_SRC
       states that robot 1 is at location (2,3).
     - A situation where a robot initially carries a shelf is indicated by attribute ~carries, e.g.
       #+BEGIN_SRC prolog
         init(object(robot, 2), value(carries, 5)).
       #+END_SRC
       states that robot 2 is carrying shelf 5.


**** Attributes Related to [[#cid-d8cd3118-7e68-4f20-8c1e-d868d32a96a3][Energy-Management]]

     - The battery level of a robot is indicated by attribute ~energy~, e.g.
       #+BEGIN_SRC prolog
         init(object(robot, 1), value(energy, 23)).
       #+END_SRC
       states that robot 1 has battery level 23.
     - The maximum energy capacity of robot's battery is indicated by attribute ~maxEnergy~, e.g.
       #+BEGIN_SRC prolog
         init(object(robot, 1), value(maxEnergy, 250)).
       #+END_SRC
       states that robots 1 has a battery with maximum energy capacity of 250.


**** Attributes Related to [[#cid-9828decd-6d59-4ccc-94c2-847b3a6b7a08][Quantity-Based Product Capacities]]

     - The maximum number of product units a robot can carry is indicated by attribute ~maxQuantity~,
       e.g.
       #+BEGIN_SRC prolog
         init(object(robot, 1), value(maxQuantity, 20)).
       #+END_SRC
       states that robots 1 can carry up to 20 product units.


**** Attributes Related to [[#cid-87f0ecc2-45ff-4d7c-8583-8b5ed4c5fbbe][Weight-Based Product Capacities]]

     - The maximum weight a robot can carry is indicated by attribute ~maxWeight~, e.g.
       #+BEGIN_SRC prolog
         init(object(robot, 1), value(maxWeight, 500)).
       #+END_SRC
       states that robots 1 can carry a payload weight of up to 500.


**** Attributes Related to [[#cid-8c423d59-0c08-422f-b94d-720a0b6908e2][Volume-Based Product Capacities]]

     - The maximum volume a robot can carry is indicated by attribute ~maxVolume~, e.g.
       #+BEGIN_SRC prolog
         init(object(robot, 1), value(maxVolume, 267)).
       #+END_SRC
       states that robots 1 can carry a payload volume of up to 267.


**** Example

     #+BEGIN_SRC prolog
       init(object(robot, 1), value(maxEnergy, 250)).
       init(object(robot, 1), value(subtype, 3)).
       init(object(subtype(robot), 3), value(maxWeight, 500)).
     #+END_SRC
     states that
     1) robots 1 has a battery with maximum energy capacity of 250
     2) robot 1 is of object-subtype 3 (as explained in [[#cid-035d4a73-f8d3-482b-b091-6dddef6d65ae][Object-Subtypes]])
     3) robots of object-subtype 3 can carry a payload of up to 500 weight


*** Shelves

    [[*Shelves][Shelves]] use object-type ~shelf~ for their specification.

**** Attributes Related to [[#cid-b0f981f8-3202-42c0-a46e-aa6f1a52629b][Default Domain]]

     - The grid position of a shelf is indicated by attribute ~at~, e.g.
       #+BEGIN_SRC prolog
         init(object(shelf, 1), value(at, (2,3))).
       #+END_SRC
       states that shelf 1 is at location (2,3).


**** Attributes Related to [[#cid-9828decd-6d59-4ccc-94c2-847b3a6b7a08][Quantity-Based Product Capacities]]

     - The quantitative capacity of a shelf is indicated by attribute
       ~maxQuantity~, e.g.
       #+BEGIN_SRC prolog
         init(object(shelf, 1), value(maxQuantity, 20)).
       #+END_SRC
       states that shelf 1 has a maximum quantitative capacity of 20.


**** Attributes Related to [[#cid-87f0ecc2-45ff-4d7c-8583-8b5ed4c5fbbe][Weight-Based Product Capacities]]

     - The weight-based capacity of a shelf is indicated by attribute
       ~maxWeight~, e.g.
       #+BEGIN_SRC prolog
         init(object(shelf, 1), value(maxWeight, 23)).
       #+END_SRC
       states that shelf 1 has a maximum weight capacity of 23.


**** Attributes Related to [[#cid-8c423d59-0c08-422f-b94d-720a0b6908e2][Volume-Based Product Capacities]]

     - The volume-based capacity of a shelf is indicated by attribute
       ~maxVolume~, e.g.
       #+BEGIN_SRC prolog
         init(object(shelf, 1), value(maxVolume, 267)).
       #+END_SRC
       states that shelf 1 has a maximum volume capacity of 267.


**** Example

     #+BEGIN_SRC prolog
       init(object(shelf, 3), value(maxVolume, 200)).
       init(object(shelf, 3), value(subtype, 1)).
       init(object(subtype(shelf), 1), value(maxWeight, 23)).
     #+END_SRC
     states that
     1) shelf 3 has a maximum volume capacity of 200.
     2) shelf 3 is of object-subtype 1 (as explained in Sec. [[#cid-035d4a73-f8d3-482b-b091-6dddef6d65ae][Object-Subtypes]])
     3) shelves of object-subtype 1 have a maximum weight capacity of 23.


*** Products

    [[*Products][Products]] use object-type ~product~ for their specification.

**** Attributes Related to [[#cid-b0f981f8-3202-42c0-a46e-aa6f1a52629b][Default Domain]]

     - A shelf on which a product is stored on is indicated by attribute ~on~, e.g.,
       #+BEGIN_SRC prolog
         init(object(product, 45), value(on, (5, 280)).
       #+END_SRC
       states that 280 units of product 45 are on shelf 5.


**** Attributes Related to [[#cid-49448523-5e9b-4ed2-ac1a-6754d838b85c][Disregard of Product Quantities]]

     - In case product quantities are ignored, the value of ~on~ is a single integer indicating the
       shelf, e.g.
       #+BEGIN_SRC prolog
         init(object(product, 45), value(on, 5).
       #+END_SRC
       states that product 45 is on shelf 5 in unlimited quantity.


**** Attributes Related to [[#cid-87f0ecc2-45ff-4d7c-8583-8b5ed4c5fbbe][Weight-Based Product Capacities]]

     - The weight of a product is indicated by attribute ~weight~, e.g.
       #+BEGIN_SRC prolog
         init(object(product, 1), value(weight, 4)).
       #+END_SRC
       states that product 1 has weight 4.


**** Attributes Related to [[#cid-8c423d59-0c08-422f-b94d-720a0b6908e2][Volume-Based Product Capacities]]

     - The volume of a product is indicated by attribute ~volume~, e.g.
       #+BEGIN_SRC prolog
         init(object(product, 1), value(volume, 15)).
       #+END_SRC
       states that product 1 has a volume 15.


**** Example

     #+BEGIN_SRC prolog
       init(object(product, 1), value(volume, 5)).
       init(object(product, 1), value(subtype, 3)).
       init(object(subtype(product), 3), value(weight, 10)).
     #+END_SRC
     states that
     1) product 1 has volume 5
     2) products 1 is of object-subtype 3 (as explained in Sec. [[#cid-035d4a73-f8d3-482b-b091-6dddef6d65ae][Object-Subtypes]])
     3) products of object-subtype 3 have a weight of 10.


*** Orders

     [[*Orders][Orders]] use object-type ~order~ for their specification.

**** Attributes Related to [[#cid-b0f981f8-3202-42c0-a46e-aa6f1a52629b][Default Domain]]

     - Lines of an order, i.e., requests of products in a certain quantity, are indicated by
       attribute ~line~, e.g.,
       #+BEGIN_SRC prolog
         init(object(order, 7), value(line, (467, 2))).
         init(object(order, 7), value(line, (77, 12))).
       #+END_SRC
       states that order 7 requests 2 units of product 467, and 12 units of product 77.

**** Attributes Related to [[#cid-58b1d9d1-786b-4f92-b233-ddeb1e29dbb9][Order Assignment to Picking Stations]]

     - The picking station of an order is indicated by attribute ~pickingStation~, e.g.
       #+BEGIN_SRC prolog
         init(object(order, 7), value(pickingStation, 4).
       #+END_SRC
       states that order 7 is assigned to picking station 4.

**** Attributes Related to [[#cid-88ef4c01-95a6-45f6-9d2c-b3b3c493964e][Expiring Orders]]

     - The expiration timeout of an order is indicated by attribute ~expirationTimeOut~, e.g.
       #+BEGIN_SRC prolog
         init(object(order, 7), value(expirationTimeOut, 20).
       #+END_SRC
       states that order 7 expires 20 time steps after the time step of its arrival.

**** Example

     #+BEGIN_SRC prolog
       init(object(order, 1), value(line, (5, 30))).
       init(object(order, 1), value(pickingStation, 2)).
       init(object(order, 1), value(expirationTimeOut, 12)).
     #+END_SRC
     states that
     1) order 1 has and order line for 30 units of product 5.
     2) order 1 is assigned to picking station 2.
     3) order 1 expires after 12 time steps.


*** Picking Stations

    [[*Picking Stations][Picking stations]] use object-type ~pickingStation~ for their specification.

**** Attributes Related to [[#cid-b0f981f8-3202-42c0-a46e-aa6f1a52629b][Default Domain]]

    - The grid position of a picking station is indicated by attribute ~at~, e.g.
      #+BEGIN_SRC prolog
        init(object(pickingStation, 1), value(at, (2,3))).
      #+END_SRC
      states that pickingStation 1 is at location (2,3).


*** Charging Stations (Introduced by [[#cid-d8cd3118-7e68-4f20-8c1e-d868d32a96a3][Energy Management]])

    Charging stations use object-type ~chargingStation~ for their specification.

**** Attributes Related to [[#cid-d8cd3118-7e68-4f20-8c1e-d868d32a96a3][Energy Management]]

     - The grid position of a charging station is indicated by attribute ~at~, e.g.
       #+BEGIN_SRC prolog
         init(object(chargingStation, 1), value(at, (2,3))).
       #+END_SRC
       states that chargingStation 1 is at location (2,3).

     - The charge rate of a charging station is indicated by attribute ~chargeRate~, e.g.
       #+BEGIN_SRC prolog
         init(object(chargingStation, 1), value(chargeRate, (5,2))).
       #+END_SRC
       states that chargingStation 1 charges 5 battery levels in 2 time steps.

**** Example

      #+BEGIN_SRC prolog
        init(object(chargingStation, 1), value(at, (2, 3))).
        init(object(chargingStation, 1), value(subtype, 2).
        init(object(subtype(charginStation), 2), value(chargeRate, (5, 2)).
     #+END_SRC
     states that
     1) charging station 1 is located at (2,3).
     2) charging station 1 is of object-subtype 2.
     3) charging stations of object-subtype 2 have a charge rate of 5 battery levels in 2 time
        steps.


*** Restocking Station (Introduced by [[#cid-d84e72a4-2202-4331-8636-b56dd264c641][Replenishment]])

    Restocking stations use object-type ~restockingStation~ for their specification.

**** Attributes Related to [[#cid-d84e72a4-2202-4331-8636-b56dd264c641][Replenishment]]

     - The grid position of a restocking station is indicated by attribute ~at~, e.g.
       #+BEGIN_SRC prolog
         init(object(restockingStation, 1), value(at, (2,3))).
       #+END_SRC
       states that restockingStation 1 is at location (2,3).


* Output Format

  All planned actions are represented as ~occurs/3~ facts of the format
  #+BEGIN_SRC prolog
     occurs(object(<object-type>, <object-id>), action(<action-type>, <action-args>), <time step>)
  #+END_SRC
  where
  - function ~object~ refers to an object by its type ~<object-type>~ and relative identifier ~<object-id>~,
    e.g. ~object(robot, 34)~ for a robot with RID 34
  - function ~action~ specifies the type of action ~<action-type>~ together with a tuple of input
    arguments ~<action-args>~ to be executed by the associated object; specifically, actions
    are so far only defined for object type ~robot~ with the following action types:
    + ~move~
      * tells the robot to move in a cardinal direction to an adjacent grid node
      * takes a binary ~<action-args>~ tuple with the domain ~(-1,0), (1,0), (0,-1), (0,1)~ that
        indicates the four possible movement directions 'West, East, South, North' in relation to
        the robot's current location
    + ~pickup~
      * tells the robot to pick up the shelf at its current location
      * takes an empty ~<action-args>~ tuple
    + ~putdown~
      * tells the robot to put down the shelf at its current location
      * takes an empty ~<action-args>~ tuple
    + ~deliver~
      * for the [[#cid-b0f981f8-3202-42c0-a46e-aa6f1a52629b][default domain]] (i.e. plans that consider product quantities):
        + tells the robot to deliver a certain amount of units of a product to (partially) fill a specific order
        + is only applicable if robot is at a picking station
        + takes as ~<action-args>~ a triple comprised by
          1. the object ID of the order
          2. the object ID by the Product
          3. the number of product units
      * in case [[#cid-49448523-5e9b-4ed2-ac1a-6754d838b85c][product quantities are ignored]]:
        + tells the robot to deliver a product to fill a specific order
        + is only applicable if robot is at a picking station
        + takes as ~<action-args>~ a tuple comprised by
          1. the object ID of the order
          2. the object ID by the Product
  - ~<time step>~ is an integer constant equal to the time step when the action should be performed


* Example Instance and Plan

  This is an example rooted in the [[#cid-b0f981f8-3202-42c0-a46e-aa6f1a52629b][default problem domain]]. All files related to this example can be
  found in =./examples/default=.

** Instance (=./examples/default/instance.asp=)

   #+BEGIN_SRC prolog
     %
     % Warehouse grid nodes
     %
     init(object(node,1),value(at,(1,1))).
     init(object(node,2),value(at,(2,1))).
     init(object(node,3),value(at,(3,1))).
     init(object(node,4),value(at,(4,1))).
     init(object(node,5),value(at,(5,1))).
     init(object(node,6),value(at,(6,1))).
     init(object(node,7),value(at,(7,1))).
     init(object(node,8),value(at,(1,2))).
     init(object(node,9),value(at,(2,2))).
     init(object(node,10),value(at,(3,2))).
     init(object(node,11),value(at,(4,2))).
     init(object(node,12),value(at,(5,2))).
     init(object(node,13),value(at,(6,2))).
     init(object(node,14),value(at,(7,2))).
     init(object(node,15),value(at,(1,3))).
     init(object(node,16),value(at,(2,3))).
     init(object(node,17),value(at,(3,3))).
     init(object(node,18),value(at,(4,3))).
     init(object(node,19),value(at,(5,3))).
     init(object(node,20),value(at,(6,3))).
     init(object(node,21),value(at,(7,3))).
     init(object(node,22),value(at,(1,4))).
     init(object(node,23),value(at,(2,4))).
     init(object(node,24),value(at,(3,4))).
     init(object(node,25),value(at,(4,4))).
     init(object(node,26),value(at,(5,4))).
     init(object(node,27),value(at,(6,4))).
     init(object(node,28),value(at,(7,4))).
     init(object(node,29),value(at,(1,5))).
     init(object(node,30),value(at,(2,5))).
     init(object(node,31),value(at,(3,5))).
     init(object(node,32),value(at,(4,5))).
     init(object(node,33),value(at,(5,5))).
     init(object(node,34),value(at,(6,5))).
     init(object(node,35),value(at,(7,5))).
     init(object(node,36),value(at,(1,6))).
     init(object(node,37),value(at,(2,6))).
     init(object(node,38),value(at,(3,6))).
     init(object(node,39),value(at,(4,6))).
     init(object(node,40),value(at,(5,6))).
     init(object(node,41),value(at,(6,6))).
     init(object(node,42),value(at,(7,6))).
     init(object(node,43),value(at,(1,7))).
     init(object(node,44),value(at,(2,7))).
     init(object(node,45),value(at,(3,7))).
     init(object(node,46),value(at,(4,7))).
     init(object(node,47),value(at,(5,7))).
     init(object(node,48),value(at,(6,7))).
     init(object(node,49),value(at,(7,7))).

     %
     % Highway grid nodes
     %
     init(object(highway,1),value(at,(1,1))).
     init(object(highway,4),value(at,(4,1))).
     init(object(highway,7),value(at,(7,1))).
     init(object(highway,8),value(at,(1,2))).
     init(object(highway,9),value(at,(2,2))).
     init(object(highway,10),value(at,(3,2))).
     init(object(highway,11),value(at,(4,2))).
     init(object(highway,12),value(at,(5,2))).
     init(object(highway,13),value(at,(6,2))).
     init(object(highway,14),value(at,(7,2))).
     init(object(highway,15),value(at,(1,3))).
     init(object(highway,18),value(at,(4,3))).
     init(object(highway,21),value(at,(7,3))).
     init(object(highway,22),value(at,(1,4))).
     init(object(highway,23),value(at,(2,4))).
     init(object(highway,24),value(at,(3,4))).
     init(object(highway,25),value(at,(4,4))).
     init(object(highway,26),value(at,(5,4))).
     init(object(highway,27),value(at,(6,4))).
     init(object(highway,28),value(at,(7,4))).
     init(object(highway,29),value(at,(1,5))).
     init(object(highway,32),value(at,(4,5))).
     init(object(highway,35),value(at,(7,5))).
     init(object(highway,36),value(at,(1,6))).
     init(object(highway,37),value(at,(2,6))).
     init(object(highway,38),value(at,(3,6))).
     init(object(highway,39),value(at,(4,6))).
     init(object(highway,40),value(at,(5,6))).
     init(object(highway,41),value(at,(6,6))).
     init(object(highway,42),value(at,(7,6))).
     init(object(highway,43),value(at,(1,7))).
     init(object(highway,46),value(at,(4,7))).
     init(object(highway,49),value(at,(7,7))).

     %
     % Shelves
     %
     init(object(shelf,1),value(at,(5,3))).
     init(object(shelf,2),value(at,(3,3))).
     init(object(shelf,3),value(at,(2,3))).
     init(object(shelf,4),value(at,(6,3))).
     init(object(shelf,5),value(at,(5,5))).
     init(object(shelf,6),value(at,(2,5))).

     %
     % Products on Shelves
     %
     init(object(product,1),value(on,(6,10))).
     init(object(product,2),value(on,(6,1))).
     init(object(product,3),value(on,(6,1))).

     %
     % Picking Stations
     %
     init(object(pickingStation,1),value(at,(3,1))).


     %
     % Robots
     %
     init(object(robot,1),value(at,(2,7))).
     init(object(robot,2),value(at,(1,7))).

     %
     % Orders
     %
     init(object(order,1),value(line,(1,2))).
     init(object(order,1),value(pickingStation,1)).
     init(object(order,2),value(line,(1,5))).
     init(object(order,2),value(pickingStation,1)).
     init(object(order,3),value(line,(2,1))).
     init(object(order,3),value(line,(3,1))).
     init(object(order,3),value(pickingStation,1)).
   #+END_SRC

   Visualization of the instance below (robots are depicted as single colored squares, shelves as
   circles, picking stations as yellow and black striped squares, and highway nodes as gray fields):
   #+CAPTION: Visualization of instance =./examples/default/instance.asp=
   #+NAME: fig:example-inst
   [[file:img/example_inst.png]]


** Possible Plan (=./examples/default/outcome.txt=)

   #+BEGIN_SRC prolog
     occurs(object(robot,1),action(move,(0,-1)),1).
     occurs(object(robot,2),action(move,(0,-1)),1).
     occurs(object(robot,1),action(move,(0,-1)),2).
     occurs(object(robot,2),action(move,(1,0)),2).
     occurs(object(robot,1),action(move,(0,-1)),3).
     occurs(object(robot,2),action(move,(0,-1)),3).
     occurs(object(robot,1),action(move,(0,-1)),4).
     occurs(object(robot,2),action(pickup,()),4).
     occurs(object(robot,1),action(move,(1,0)),5).
     occurs(object(robot,2),action(move,(1,0)),5).
     occurs(object(robot,2),action(move,(0,-1)),6).
     occurs(object(robot,1),action(pickup,()),6).
     occurs(object(robot,1),action(move,(1,0)),7).
     occurs(object(robot,2),action(move,(0,-1)),7).
     occurs(object(robot,2),action(move,(0,-1)),8).
     occurs(object(robot,1),action(move,(-1,0)),9).
     occurs(object(robot,2),action(move,(0,-1)),9).
     occurs(object(robot,2),action(deliver,(2,1,5)),10). % order line (1,5) of order 2 fulfilled
     occurs(object(robot,2),action(deliver,(1,1,2)),11). % order line (1,2) of order 1 fulfilled
     occurs(object(robot,1),action(move,(0,-1)),12).
     occurs(object(robot,2),action(deliver,(3,2,1)),12). % order line (2,1) of order 3 fulfilled
     occurs(object(robot,2),action(deliver,(3,3,1)),13). % order line (3,1) of order 3 fulfilled
   #+END_SRC


* Alternative Problem Domain: GTAPF

  In place of the [[#cid-b0f981f8-3202-42c0-a46e-aa6f1a52629b][default problem domain]], we can use /General Task Assignment and Path Finding
  (GTAPF)/ [[cite:ngobsoscye17a]] as an alternative. Above all, GTAPF portrays a strong simplification
  of the default problem domain and hence offers a great starting point to address scalability
  issues.

  TODO


* References

#+BIBLIOGRAPHY: ./lit.bib plain


* Footnotes

[fn:notimplemented] Feature not yet supported by the instance generator.
